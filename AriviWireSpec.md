# ARIVI Wire Specification 

## 1) Handshake Frame

This type of frame contains handshake of the connection.

 1. **HANDSHAKE_REQUEST:** Initially Handshake-Initiator sends supported protocol version list,supported encryption mode list, session id and its public key along with INVITE opcode field set to Handshake-Responder.
    
2.  **HANDSHAKE_RESPONSE:** Using received Handshake-Initiator’s public key and generated ephemeral Keys, Handshake-Responder computes shared secret for communication and encrypts challenge ciphertext, then sends it back negotiated protocol version, negotiated encryption mode, the ephemeral public key and challenge ciphertext with AUTH_CHALLENGE as opcode to the Handshake-Initiator.
    
3.  **HANDSHAKE_ACK:** Handshake-Initiator decrypts received challenge cipher text using derived shared secret and if successful sends an ACK to the Handshake-Responder, else an ERROR frame will be sent that marks the closure of this unsucessful handshake.


---

## 2) Regular Frame

This is type of frame is used for regular messages containing application data payload that is typically encrypted per the application's needs. 


---

## 3) Reset/Close Frame

This frame contains information about the closing/ resetting connection, If opcode field is RESET then session of the connection resets, if it is CLOSE then the connection closes



---
## 4) Error Frame


This frame contains information about the error in connection, the opcode of this type of frame is set to **ERROR** and the **ERROR Descriptor** field is present in this frame. 



---



### Version: \[1 Byte\]

Version of the Wire Spec this will be negotiated at the initial messages, Client and server will negotiated this by taking latest of common version, For Ex. Client has v1,v2 and Server has v1,v2,v3 then the communication version will be v2 , This field is 32 bit long.

---
### Opcode: \[1 Byte\]

 - **ERROR - 0x00**

Indicates an error processing a request. The Error descriptor of the message will contain an error code followed by a error message. Then, depending on the exception, more content may follow. The error codes are defined in along with their additional content if any
    
-   **HANDSHAKE_REQUEST 0x01**
This opcode indicates that the given frame is HANDSHAKE_REQUEST step (1 of 3) in message handshake.
    

-   **HANDSHAKE_RESPONSE 0x02**
This opcode indicates that the given frame is HANDSHAKE_RESPONSE step (2 of 3) in message handshake.
    
-   **HANDSHAKE_ACK - 0x03**
This opcode indicates that the given frame is HANDSHAKE_ACK step (3 of 3) in message handshake.
    
-   **Options 0x04**
Asks the server to return what service options are supported. The body of an OPTIONS message should be empty and the server will respond with a SUPPORTED message such as services Kademlia,Chord,Block
    

-   **Reset, 0x05**
Resets the connection session
    

-   **Close 0x06**
Terminates the current connection with the server
    

-   **Ping 0x07**
A Ping frame may serve either as a keepalive or as a means to verify that the remote endpoint is still alive.
    
-   **Pong 0x08**
A Pong frame sent in response to a Ping frame. A Pong frame may be sent unsolicited to serve an unidirectional heartbeat.  A response to an unsolicited Pong frame is not expected.
    
----

### Public Flags: \[1 Byte\]

-   **Fragmentation** : This bit is set for fragmented messages. Unfragmented messages will not have this bit set.
    
-   **Initiator:** This bit will be set to 1 if the Connection was initiated by this endpoint. Will be useful in maintain the counter/nonce exclusivity for certain symmetric encryption schemes like AES / Poly where unique nonce is needed.
    
-   **Encryption  Type (0 None,1 AES CTR, 2 PolyChaCha)**
	- This defines the encryption method used for encryption of payload , two bits is allocated for this

			00 - None

			01 - AES CTR Mode

			10 - ChaChaPoly


-   **Encoding: **
	- This field is used to represent the encoding used for the message it can be UTF-8,CBOR,JSON,Google’s Protocol Buffer, etc
    

  

-   **TransportType:**
	-  If this bit is set TCP otherwise UDP.

---

### SessionId  \[4 Bytes\] 

 - This is unique identifier which is generated by client using some random function. This is used to map negotiated protocol version,shared secret key used for encryption,negotiated encoding type of subprotocol, public key of the other party.
 - We need to store key (sessionId) and value ( (protocolContext, port ,ip ,transport-type, encryption-format, app-encoding-type)) in sessionHashMap for further reference.

---


### Payload-Length \[3 Byte\] 

 -  This denote the length of message in payload field. This field size is 3 Bytes which gives 2^(3*8) bits = 2 MB max size of payload but actual size will be 500KB

  ---
  
  

### Descriptor \[2 Bytes\]

 -  This is optional field in the frame. If opcode value is ERROR, then this field serves as an Error descriptor. Else if the opcode value is SUPPORTED then this field will contain a list of supported Sub-Protocols. This field is not used for other opcodes.

---
  
  
  

### Message id: \[1 Byte\] (Present Only if fragmentation bit is set) 
- All message of same fragment will have same message id

  
---

### Fragment number \[1 or 2 Bytes\]
- If the first bit is 0, then the next 7 bits indicate the fragment number, fragment counting starts from 1.
- If the first bit is set to 1, then the next 15 bits indicate the fragment number.
- If the first 8 bits are zeroes, then this fragment is considered to be the final fragment.

---

### Payload marker \[1 Byte\]
- Subprotocol 

 ---
 
### Payload  \[Max 2MB, but actual 500KB\]

- This is the actual payload of the frame which can be of max size 2MB but actual size is 500KB in TCP, 50KB in UDP

---
