# ARIVI Wire Specification 

## Handshake Frame

This type of frame contains handshake of the connection.

 1. **INVITE:** Initially Handshake-Initiator sends available protocol version list,supported encryption mode list, supported encoding list, session id and its public key along with INVITE opcode field set to Handshake-Responder.
    
2.  **AUTH_CHALLENGE:** Using received Handshake-Initiator’s public key and generated ephemeral Keys, Handshake-Responder computes shared secret for communication and encrypts challenge ciphertext, then sends it back negotiated protocol version,negotiated encryption mode,negotiated encoding mode along with the ephemeral public key and challenge ciphertext with AUTH_CHALLENGE opcode field set, to Handshake-Initiator.
    
3.  **AUTH_RESPONSE:** Handshake-Initiator decrypts received challenge cipher text using derived shared secret and sends this to Handshake-Responder, then Handshake-Responder verifies it is properly decrypted or not, if it is not proper, Handshake-Initiator  will replay with an ERROR frame . When Handshake-Responder receives error frame it will send connection reset request. AUTH_RESPONSE opcode field is set.

![enter image description here](https://user-images.githubusercontent.com/8463082/38079498-ab7d8622-335c-11e8-8007-7f12502346cb.png)
---

## Regular Frame

This is type of frame is used for regular messages. 


---

## Reset/Close Frame

This frame contains information about the closing/ resetting connection, If opcode field is RESET then session of the connection resets, if it is CLOSE then the connection closes



---
## ERROR Frame


This frame contains information about the error in connection, the opcode of this type of frame is set to **ERROR** and the **ERROR Descriptor** field is present in this frame. 



---



**Version: \[1 Byte\]**
	 Version of the Wire Spec this will be negotiated at the initial messages, Client and server will negotiated this by taking latest of common version, For Ex. Client has v1,v2 and Server has v1,v2,v3 then the communication version will be v2 , This field is 32 bit long.

---
**Opcode: \[1 Byte\]**

 - **ERROR - 0x00**
	-   Indicates an error processing a request. The Error descriptor of the message will contain an error code followed by a error message. Then, depending on the exception, more content may follow. The error codes are defined in along with their additional content if any
    
-   **INVITE 0x01**
	-   This opcode indicates that the given frame is INVITE step in message handshake.
    

-   **AUTH_CHALLENGE 0x02**
  
	-   This opcode indicates that the given frame is AUTH_CHALLENGE step in message handshake.
    
-   **AUTH_RESPONSE - 0x03**
	-   This opcode indicates that the given frame is AUTH_RESPONSE step in message handshake.
    
-   **Options 0x04**
	-   Asks the server to return what service options are supported. The body of an OPTIONS message should be empty and the server will respond with a SUPPORTED message such as services Kademlia,Chord,Block
    

-   **Reset, 0x05**
 
	-   Resets the connection session
    

-   **Close 0x06**
    -   Ends the current connection with the server
    

-   **Ping 0x07**
   
	-   A Ping frame MAY include "Application data". Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in response, unless it already received a Close frame. It SHOULD respond with Pong frame as soon as is practical.
    
-   **Pong 0x08**
   
	-   A Pong frame sent in response to a Ping frame must have identical  
    "Application data" as found in the message body of the Ping frame  
    being replied to.
    

> Note: Ping and Pong are used to check if a connection is alive
----

## Public Flags: \[1 Byte\]

-   **Fragmentation** : This bit is set for fragmented messages. Unfragmented messages will not have this bit set.
    
-   **Initiator:** This bit will be set to 1 if the Connection was initiated by this endpoint. Will be useful in maintain the counter/nonce exclusivity for certain symmetric encryption schemes like AES / Poly where unique nonce is needed.
    
-   **Encryption  Type (0 None,1 AES CTR, 2 PolyChaCha)**
	- This defines the encryption method used for encryption of payload , two bits is allocated for this

			00 - None

			01 - AES CTR Mode

			10 - ChaChaPoly

  

-   Encoding: 
	- This field is used to represent the encoding used for the message it can be UTF-8,CBOR,JSON,Google’s Protocol Buffer, etc
    

  

-   TransportType:
	-  If this bit is set TCP otherwise UDP.

---

### SessionId  \[4 Bytes\] 

 - This is unique identifier which is generated by client using some random function. This is used to map negotiated protocol version,shared secret key used for encryption,negotiated encoding type of subprotocol, public key of the other party.
 - We need to store key (sessionId) and value ( (protocolContext, port ,ip ,transport-type, encryption-format, app-encoding-type)) in sessionHashMap for further reference.

---


### Payload-Length \[3 Byte\] 

 -  This denote the length of message in payload field. This field size is 3 Bytes which gives 2^(3*8) bits = 2 MB max size of payload but actual size will be 500KB

  ---
  
  

### Error Descriptor \[2 Bytes\]

 -  This is optional field in the frame. If opcode field is ERROR, then this field will be present in the frame. Otherwise it is absent.

---
  
  
  

### Message id: \[1 Byte\] (Present Only if fragmentation bit is set) 
- All message of same fragment will have same message id

  
---

### Fragment number \[1 or 2 Bytes\]
- If the first bit is 0, then the next 7 bits indicate the fragment number, fragment counting starts from 1.
- If the first bit is set to 1, then the next 15 bits indicate the fragment number.
- If the first 8 bits are zeroes, then this fragment is considered to be the final fragment.

---

### Payload marker \[1 Byte\]
- Subprotocol 

 ---
 
### Payload  \[Max 2MB, but actual 500KB\]

- This is the actual payload of the frame which can be of max size 2MB but actual size is 500KB in TCP, 50KB in UDP

---
